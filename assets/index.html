<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WASM C Compiler & Disassembler + Unicorn Debugger</title>

  <!-- CodeMirror CSS (base + theme) -->
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css" />
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/dracula.min.css" />

  <style>
    html, body {
      height:100%; margin:0; padding:0;
      background:#282a36; color:#f8f8f2; font-family:sans-serif;
    }
    body {
      display:flex; flex-direction:column; padding:16px; gap:12px;
    }
    .editor-container {
      height:200px; border:1px solid #44475a;
      resize:vertical; overflow:hidden;
    }
    .CodeMirror {
      width:100%; height:100%; font-family:monospace; font-size:14px;
    }
    .step-highlight {
      background:rgba(80,250,123,0.2) !important;
    }
    .button-row {
      display:flex; gap:8px; flex-wrap:wrap;
    }
    button {
      background:#6272a4; color:#f8f8f2; border:none;
      padding:6px 12px; cursor:pointer;
    }
    #cpu-visual {
      display:flex; gap:16px; margin-top:12px;
    }
    #reg-box, #stack-box {
      background:#44475a; padding:8px;
      font-family:monospace; color:#f8f8f2;
      overflow:auto; max-height:200px;
    }
    #reg-box { flex:0 0 200px; }
    #stack-box { flex:1; border-left:1px solid #6272a4; padding-left:12px; }
  </style>
</head>
<body>
  <h2>1. Enter C Code</h2>
  <div class="editor-container"><textarea id="editor"></textarea></div>

  <div class="button-row">
    <button onclick="compileAndDisasm()">Compile &amp; Disasm</button>
    <button onclick="debugInit()">Start Debug</button>
    <button onclick="step()">Step</button>
    <button onclick="resetStepper()">Reset</button>
  </div>

  <h2>2. Hex Output</h2>
  <div class="editor-container" style="height:100px;">
    <textarea id="hex-editor"></textarea>
  </div>

  <h2>3. Disassembly</h2>
  <div class="editor-container" style="height:150px;">
    <textarea id="asm-editor"></textarea>
  </div>

  <h2>4. CPU State</h2>
  <div class="editor-container" style="height:150px;">
    <textarea id="cpu-editor"></textarea>
  </div>

  <div id="cpu-visual">
    <div id="reg-box"><strong>Registers</strong></div>
    <div id="stack-box"><strong>Stack</strong></div>
  </div>

  <!-- 1) Unicorn.js (x86 build) -->
  <!-- Unicorn loader -->
  <script>
    // tell Unicorn.js where to fetch its .wasm
    var Module = {
      locateFile: function(filename) {
        if (filename.endsWith('.wasm')) {
          return 'libs/unicorn/dist/' + filename;
        }
        return filename;
      }
    };
  </script>
  <script src="libs/unicorn/dist/unicorn-x86.min.js"></script>
  

    

  <!-- 2) Capstone for disassembly -->
  <script src="../libs/build-wrapper/capstone.js"></script>

  <!-- 3) TinyCC via Emscripten -->
  <script type="module">
    import('../libs/build-tcc/tcc.mjs').then(m => window._createTCC = m.default);
  </script>

  <!-- 4) CodeMirror -->
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/clike/clike.min.js"></script>

  <script>
  // ————————————————————— Globals —————————————————————
  let editor, hexEditor, asmEditor, cpuEditor;
  let capstoneModule, disasmFunc, tccModule;
  let instList = [], instIndex = 0;
  let ripToAsmRow = {}, ripToSrcLine = {};
  let currentSourceLine = null;
  let uc = null, codeBytes = null;
  const textBase = 0x1000;

  let cpuState = { rip:textBase, rsp:0x8000, rbp:0x8000, stack:[] };

  // ————————————————— Setup Editors —————————————————
  window.onload = () => {
    editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
      mode:'text/x-csrc', theme:'dracula', lineNumbers:true
    });
    hexEditor = CodeMirror.fromTextArea(document.getElementById('hex-editor'), {
      mode:'plaintext', theme:'dracula', readOnly:true
    });
    asmEditor = CodeMirror.fromTextArea(document.getElementById('asm-editor'), {
      mode:'plaintext', theme:'dracula', readOnly:true
    });
    cpuEditor = CodeMirror.fromTextArea(document.getElementById('cpu-editor'), {
      mode:'plaintext', theme:'dracula', readOnly:true
    });

    editor.setValue(`__attribute__((noinline)) int test(int a,int b){
  int x=4; x++;
  return a+b;
}
int main(){
  int b=test(3,44);
  for(int i=0;i<3;i++){
    b+=i;
  }
  return b;
}`);

    // init Capstone
    createCapstoneModule({
      print: txt => appendAsm(txt),
      printErr: txt => console.error(txt)
    }).then(m => {
      capstoneModule = m;
      disasmFunc = capstoneModule.cwrap('disasm_x86', null, ['array','number']);
      appendAsm('✅ Capstone loaded.');
    });
  };

  // ————————————————— Display Helpers —————————————————
  function updateRegisters(){
    const r=cpuState;
    const s=`RIP:0x${r.rip.toString(16)}\nRSP:0x${r.rsp.toString(16)}\nRBP:0x${r.rbp.toString(16)}`;
    document.getElementById('reg-box')
            .innerHTML=`<strong>Registers</strong><pre>${s}</pre>`;
  }
  function updateStack(){
    const lines=cpuState.stack.map((v,i)=>
      `0x${(cpuState.rsp+i*8).toString(16).padStart(8,'0')}: 0x${v.toString(16).padStart(16,'0')}`
    );
    document.getElementById('stack-box')
      .innerHTML=`<strong>Stack</strong><pre>${lines.join('\n')}</pre>`;
    const prev=cpuEditor.getValue();
    cpuEditor.setValue(prev+lines.join('\n')+'\n\n');
    cpuEditor.scrollTo(null, cpuEditor.getScrollInfo().height);
  }

  // ————————————————— Compile & Disasm —————————————————
  async function compileAndDisasm(){
    asmEditor.setValue('');
    ripToAsmRow = {};
    ripToSrcLine = {};
    instList = []; instIndex = 0;

    tccModule = await createTCC();
    tccModule.FS.writeFile('in.c', editor.getValue());
    const lenPtr = tccModule._malloc(4),
          ptr    = tccModule.cwrap('compile_and_get_text','number',['string','number'])('in.c', lenPtr),
          size   = tccModule.HEAP32[lenPtr>>2];
    tccModule._free(lenPtr);

    codeBytes = new Uint8Array(tccModule.HEAPU8.buffer, ptr, size);
    hexEditor.setValue(formatHex(codeBytes) + '\n✅ Compiled');

    // extract symbols
    try {
      const js     = tccModule.cwrap('extract_symbols','string',['string'])('out.o'),
            parsed = JSON.parse(js,(k,v)=>
              typeof v==='string'&&/^\d+$/.test(v)?Number(v):v
            );
      window.symbolMap = {};
      for(let [n,off] of Object.entries(parsed))
        window.symbolMap[n] = textBase + Number(off);
    } catch {}

    disasmFunc(codeBytes, codeBytes.length);
    setTimeout(buildInstList, 10);
  }

  function appendAsm(line){
    line = line.trim();
    const cur = asmEditor.getValue().split('\n');
    if(cur.includes(line)) return;

    const m0 = line.match(/^0x([0-9a-f]+):/);
    if(m0 && window.symbolMap){
      const rip = parseInt(m0[1],16);
      for(const [name,addr] of Object.entries(window.symbolMap)){
        if(addr===rip && !cur.includes(name+':')){
          cur.push(name+':');
          break;
        }
      }
    }

    if(m0){
      const rip = parseInt(m0[1],16);
      const row = cur.length;
      ripToAsmRow[rip] = row;
      if(currentSourceLine!=null) ripToSrcLine[rip] = currentSourceLine;
    }

    if(/^[A-Za-z_]\w*:$/.test(line)){
      const lbl = line.slice(0,-1);
      if(lbl==='test')  currentSourceLine = 2;
      if(lbl==='main')  currentSourceLine = 7;
    }

    cur.push(line);
    asmEditor.setValue(cur.join('\n'));
    asmEditor.scrollTo(null, asmEditor.getScrollInfo().height);
  }

  function buildInstList(){
    instList = Object.keys(ripToAsmRow)
                     .map(x=>parseInt(x,10))
                     .sort((a,b)=>a-b);
    instIndex = 0;
  }

  // ————————————————— Debug Init —————————————————
  function debugInit(){
    if(!codeBytes) return alert('Compile & Disasm first');
    cpuState = { rip:textBase, rsp:0x8000, rbp:0x8000, stack:[] };
    updateRegisters(); updateStack();

    uc = new unicorn.Unicorn(unicorn.UC_ARCH_X86, unicorn.UC_MODE_64);
    uc.mem_map(textBase, codeBytes.length + 0x1000, unicorn.UC_PROT_ALL);
    uc.mem_write(textBase, codeBytes);
    uc.reg_write(unicorn.x86_const.UC_X86_REG_RIP, textBase);
    uc.reg_write(unicorn.x86_const.UC_X86_REG_RSP, cpuState.rsp);
    uc.reg_write(unicorn.x86_const.UC_X86_REG_RBP, cpuState.rbp);

    highlightAsm(textBase);
    highlightSrc(ripToSrcLine[textBase]);
  }

  // ————————————————— Single Step —————————————————
  function step(){
    if(!uc) return alert('Start Debug first');
    try {
      const curIP = uc.reg_read(unicorn.x86_const.UC_X86_REG_RIP);
      uc.emu_start(curIP, 0, 0, 1);
      const newIP = uc.reg_read(unicorn.x86_const.UC_X86_REG_RIP);
      cpuState.rip = newIP;
      cpuState.rsp = uc.reg_read(unicorn.x86_const.UC_X86_REG_RSP);
      cpuState.rbp = uc.reg_read(unicorn.x86_const.UC_X86_REG_RBP);
      updateRegisters(); updateStack();
      highlightAsm(newIP);
      highlightSrc(ripToSrcLine[newIP]);
    } catch(e){
      console.error(e);
      alert('Unicorn error: '+e);
    }
  }

  function highlightAsm(rip){
    const row = ripToAsmRow[rip];
    asmEditor.operation(()=>{
      asmEditor.getAllMarks().forEach(m=>m.clear());
      if(row!=null) asmEditor.addLineClass(row,'background','step-highlight');
      asmEditor.scrollIntoView({line:row, ch:0});
    });
  }
  function highlightSrc(line){
    editor.operation(()=>{
      editor.getAllMarks().forEach(m=>m.clear());
      if(line!=null) editor.addLineClass(line-1,'background','step-highlight');
      if(line!=null) editor.scrollIntoView({line:line-1, ch:0});
    });
  }

  // ————————————————— Reset —————————————————
  function resetStepper(){
    if(uc) uc.emu_stop();
    uc = null; codeBytes = null;
    asmEditor.setValue(''); hexEditor.setValue(''); cpuEditor.setValue('');
    ripToAsmRow = {}; ripToSrcLine = {}; currentSourceLine = null;
    editor.getAllMarks().forEach(m=>m.clear());
    document.getElementById('reg-box').innerHTML = '<strong>Registers</strong>';
    document.getElementById('stack-box').innerHTML = '<strong>Stack</strong>';
  }

  // ————————————————— Helpers —————————————————
  function formatHex(bytes){
    let out = '';
    for(let i=0;i<bytes.length;i+=16){
      const chunk = bytes.slice(i,i+16)
                     .map(b=>b.toString(16).padStart(2,'0'))
                     .join(' ');
      out += i.toString(16).padStart(4,'0')+': '+chunk+'\n';
    }
    return out;
  }

  async function createTCC(){
    return window._createTCC({ locateFile: f => '../libs/build-tcc/' + f });
  }
  </script>
</body>
</html>
