<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>WASM C Compiler & Disassembler + TinyEMU Debugger</title>

<!-- CodeMirror --------------------------------------------------------->
<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css"/>
<link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/dracula.min.css"/>

<style>
 html,body{height:100%;margin:0;padding:0;background:#282a36;color:#f8f8f2;font-family:sans-serif}
 body{display:flex;flex-direction:column;padding:16px;gap:12px}
 .editor-container{height:200px;border:1px solid #44475a;resize:vertical;overflow:hidden}
 .CodeMirror{width:100%;height:100%;font-family:monospace;font-size:14px}
 .step-highlight{background:rgba(80,250,123,.2)!important}
 .line-highlight{background:rgba(80,250,123,.2)!important}
 .button-row{display:flex;gap:8px;flex-wrap:wrap}
 button{background:#6272a4;color:#f8f8f2;border:none;padding:6px 12px;cursor:pointer}
 #cpu-visual{display:flex;gap:16px;margin-top:12px}
 #reg-box,#stack-box{background:#44475a;padding:8px;font-family:monospace;
                     color:#f8f8f2;overflow:auto;max-height:200px}
 #reg-box{flex:0 0 200px}
 #stack-box{flex:1;border-left:1px solid #6272a4;padding-left:12px}
</style>
</head>
<body>
<h2>1. Enter C Code</h2>
<div class="editor-container"><textarea id="editor"></textarea></div>

<div class="button-row">
  <button onclick="compileAndDisasm()">Compile & Disasm</button>
  <button onclick="debugInit()">Start Debug</button>
  <button onclick="step()">Step</button>
  <button onclick="resetStepper()">Reset</button>
</div>

<h2>2. Hex Output</h2>
<div class="editor-container" style="height:100px"><textarea id="hex-editor"></textarea></div>

<h2>3. Disassembly</h2>
<div class="editor-container" style="height:150px"><textarea id="asm-editor"></textarea></div>

<h2>4. CPU State</h2>
<div class="editor-container" style="height:150px"><textarea id="cpu-editor"></textarea></div>

<div id="cpu-visual">
  <div id="reg-box"><strong>Registers</strong></div>
  <div id="stack-box"><strong>Stack</strong></div>
</div>

<!-- Capstone module ----------------------------------------------------->
<script type="module">
import createCapstoneModule from '../libs/build-wrapper/capstone.js';
window.createCapstoneModule = createCapstoneModule;
</script>

<!-- TinyCC (WASM) ------------------------------------------------------->
<script type="module">
import('../libs/build-tcc/tcc.mjs').then(m=>window._createTCC=m.default);
</script>

<!-- CodeMirror ---------------------------------------------------------->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/clike/clike.min.js"></script>

<script>
/* ───────────────────────── globals ───────────────────────── */
const textBase = 0x2000;
let editor,hexEditor,asmEditor,cpuEditor;
let capstoneModule,disasmFunc,tccModule;
let ripToAsmRow={},ripToSrcLine={},srcLineToRIPs={};
let instructions=[],codeBytes=null,currentSourceLine=null;
let cpuState={};            // filled in debugInit()
let symbolMap={};
let varNameMap = {};

/* ─────────────────── util logging helper ─────────────────── */
const log=(tag,...m)=>console.log(tag,...m);

/* ─────────────────── helpers for 64-bit mem ───────────────── */
function write64(a,v){cpuState.mem[a]=v&0xffffffff;cpuState.mem[a+4]=(v>>>32)&0xffffffff}
function read64(a){return (cpuState.mem[a]??0)|((cpuState.mem[a+4]??0)<<32)}

/* mnemonic + misc helpers */
function mnem(line){return (line.split(':')[1]||'').trim().split(/\s+/)[0]?.toLowerCase()||''}
function rbpDisp(line){
  const m=line.match(/\[rbp\s*-\s*(0x[0-9a-f]+|\d+)\]/i);
  if(!m)return null;return cpuState.rbp-parseInt(m[1],m[1].startsWith('0x')?16:10);
}
function validRip(r){return r!==undefined&&ripToAsmRow.hasOwnProperty(r)}

/* ─────────────────── CodeMirror setup ─────────────────────── */
window.onload=async function setup() {
  editor      = CodeMirror.fromTextArea(document.getElementById('editor'),{mode:'text/x-csrc',theme:'dracula',lineNumbers:true});
  hexEditor   = CodeMirror.fromTextArea(document.getElementById('hex-editor'), {theme:'dracula',readOnly:true});
  asmEditor   = CodeMirror.fromTextArea(document.getElementById('asm-editor'), {theme:'dracula',readOnly:true});
  cpuEditor   = CodeMirror.fromTextArea(document.getElementById('cpu-editor'), {theme:'dracula',readOnly:true});

  editor.setValue(`__attribute__((noinline)) int bar(int x){
    volatile int t=x+1; return t;
}
__attribute__((noinline)) int foo(int y){
    volatile int d=y*2; return bar(d);
}
int main(){ volatile int in=3; int r=foo(in); return r; }`);

  capstoneModule=await createCapstoneModule({print:appendAsm,printErr:console.error});
  disasmFunc    =capstoneModule.cwrap('disasm_x86',null,['array','number','number']);
  log('✅ Capstone ready');
};

/* inject NOP markers so we can map → source line */
function injectMarkers(src) {
  return src.split('\n').map((ln, i) => {
    const idx = Math.min(i+1, 255);
    // Emit a unique 4-byte “nop” marker before every line
    return `__asm__(".byte 0x0F,0x1F,0x40,${idx}");\n${ln}`;
  }).join('\n');
}


/* ──────────────────────────────────────────────────────────
 *  very-minimal highlighters so step() never explodes
 *  - adds/removes a CSS class on the relevant line
 *  - if you don’t care about colouring, leave bodies empty
 * ────────────────────────────────────────────────────────── */
 let curAsmRow  = null;
let curSrcLine = null;

function highlightAsm(rip) {
  if (curAsmRow !== null) {
    asmEditor.removeLineClass(curAsmRow,  'background', 'step-highlight');
  }
  curAsmRow = ripToAsmRow[rip];
  if (curAsmRow != null) {
    asmEditor.addLineClass   (curAsmRow,  'background', 'step-highlight');
    asmEditor.scrollIntoView({ line: curAsmRow, ch: 0 });
  }
}

function highlightSrc(line) {
  /* remove previous highlight only if we really have one */
  if (typeof curSrcLine === 'number') {
    editor.removeLineClass(curSrcLine, 'background', 'line-highlight');
  }

  /* add new highlight only for a _number_ we recognise */
  if (typeof line === 'number') {
    curSrcLine = line - 1;                  // convert 1-based → 0-based
    editor.addLineClass(curSrcLine, 'background', 'line-highlight');
    editor.scrollIntoView({ line: curSrcLine, ch: 0 });
  } else {
    curSrcLine = undefined;                 // nothing to highlight
  }
}


/* ────────────────── compile & disassemble ─────────────────── */
async function compileAndDisasm(){
  asmEditor.setValue('');ripToAsmRow={};instructions=[];currentSourceLine=null;
  tccModule=await window._createTCC({locateFile:p=>p.endsWith('.wasm')||p.endsWith('.data')
                                           ? '../libs/build-tcc/'+p : p});
  const src=injectMarkers(editor.getValue());
  tccModule.FS.writeFile('in.c',src);

  const lenPtr=tccModule._malloc(4);
  const ptr=tccModule.cwrap('compile_and_get_text','number',['string','number'])('in.c',lenPtr);
  const size=tccModule.HEAP32[lenPtr>>2];tccModule._free(lenPtr);

  codeBytes=new Uint8Array(tccModule.HEAPU8.buffer,ptr,size);
  hexEditor.setValue(formatHex(codeBytes)+'\n✅ Compiled');

  /* ---- symbol table ---- */
  try{
    const js=tccModule.cwrap('extract_symbols','string',['string'])('out.o');
    symbolMap=JSON.parse(js,(k,v)=>/^\d+$/.test(v)?Number(v):v);
    log('SYM',symbolMap);
  }catch(e){console.warn('symbol extract failed',e)}

  /* ─ disassemble ─ */
  disasmFunc(codeBytes, codeBytes.length, textBase);
  setTimeout(() => {
    buildInstList();
    buildVarMap();      // ← new
  }, 5);

}


function buildVarMap() {
  varNameMap = {};
  // for each instruction we know the RIP → srcLine
  for (const [ripStr, srcLine] of Object.entries(ripToSrcLine)) {
    const rip = +ripStr;
    const asmRow = ripToAsmRow[rip];
    const asmLine = asmEditor.getLine(asmRow) || "";
    // look for the "store EAX → local" pattern
    const m = asmLine.match(
      /mov\s+dword ptr\s*\[rbp\s*-\s*(0x[0-9a-f]+|\d+)\]\s*,\s*eax/i
    );
    if (!m) continue;
    // parse the offset
    const offset = parseInt(m[1], m[1].startsWith("0x") ? 16 : 10);
    // pull the declaration line from the C editor
    const decl = editor.getLine(srcLine - 1).trim();
    // simple regex for "type name" – tweak if you need other types
    const nm = decl.match(
      /\b(?:unsigned\s+)?(?:int|char|long|float|double|volatile)\s+([A-Za-z_]\w*)/
    );
    if (nm) {
      varNameMap[offset] = nm[1];
    }
  }
  console.log("LOCALS MAP", varNameMap);
}



// put this just once, outside appendAsm
let currentSrcLine = null;

/* appendAsm callback (patched) */
function appendAsm(line) {
  line = line.trim();
  if (!line) return;

  // split out existing lines to avoid duplicates
  const out = asmEditor.getValue().split('\n');
  if (out.includes(line)) return;

  // extract the instruction address (RIP)
  const addrM = line.match(/^0x([0-9a-fA-F]+):/);
  if (!addrM) return;
  const rip = parseInt(addrM[1], 16);
  ripToAsmRow[rip] = out.length;

  // look for our injected NOP-marker: `nop dword ptr [rax + N]`
  // where N might be decimal ("10") or hex ("0xa")
  const markM = line.match(
    /nop\s+dword ptr\s*\[\s*rax\s*\+\s*(0x[0-9a-fA-F]+|\d+)\s*\]/i
  );
  if (markM) {
    const tok = markM[1];
    // parse hex or decimal
    currentSrcLine = tok.startsWith('0x')
      ? parseInt(tok, 16)
      : parseInt(tok, 10);
  }

  // associate this RIP → source‐line (if we have one)
  if (currentSrcLine != null) {
    ripToSrcLine[rip] = currentSrcLine;
  }

  // append and re-write the disassembly panel
  out.push(line);
  asmEditor.setValue(out.join('\n'));
}


/* build linear instruction list */
function buildInstList(){
  instructions=Object.keys(ripToAsmRow).map(x=>parseInt(x)).sort((a,b)=>a-b);
  log('INST',instructions.map(i=>'0x'+i.toString(16)));
}

/* ─────────────────── debugger init ────────────────────────── */
function debugInit(){
  if(!codeBytes)return alert('Compile first!');
  const start=(symbolMap.main??0)+textBase;

  cpuState = {		
    rip:start, rsp:0x8000, rbp:0x8000,		
    eax:0, ecx:0,		
    rdi:0, // ← add (or keep edi if you prefer 32-bit)		
    ZF:false, SF:false, OF:false,		
    mem:{}, stack:[]		
  };


  updateUI();
  log(`DBG start at 0x${start.toString(16)}`);
}

// --------------------------------------------------------------------------
//  SAFE-LOOKUP helper (keep this just once, above step or at the top)
// --------------------------------------------------------------------------
const lookup = name => typeof window[name] === 'function'
                        ? window[name]
                        : () => {};            // harmless no-op



                        /* ------------------------------------------------------------------
 *  helper: dump a 5-slot window around RSP (RSP ± 16 bytes)
 * ------------------------------------------------------------------ */
 function stackWindow () {
  const win = [];
  const top    = cpuState.rsp + 0x10;   // two slots above
  const bottom = cpuState.rsp - 0x10;   // two slots below

  for (let a = top; a >= bottom; a -= 8) {
    const empty = cpuState.mem[a] === undefined &&
                  cpuState.mem[a + 4] === undefined;
    const val   = empty ? '   ??'
                        : '0x' + read64(a).toString(16).padStart(16, '0');

    let mark = '';
    if (a === cpuState.rsp && a === cpuState.rbp) mark = '← RSP, ← RBP';
    else if (a === cpuState.rsp)                  mark = '← RSP';
    else if (a === cpuState.rbp)                  mark = '← RBP';

    win.push(`0x${a.toString(16).padStart(4, '0')}: ${val} ${mark}`);
  }
  return win.join('\n');
}

/* ── pretty console dump for the current RIP ──────────────── */
function dbgLine(rip){
  const srcLine  = ripToSrcLine[rip];          // 1-based or undefined
  const asmRow   = ripToAsmRow [rip];          // 0-based CodeMirror row
  const srcTxt   = (typeof srcLine === 'number')
                   ? editor.getLine(srcLine-1).trim()
                   : '(no src)';
  const asmTxt   = (asmRow != null)
                   ? asmEditor.getLine(asmRow).split(':')[1].trim()
                   : '(no asm)';

  console.log(
`SRC  L${srcLine ?? '-'}\t: ${srcTxt}
ASM  L${asmRow ?? '-'}\t: ${asmTxt}
────────────────────────────────────────────`);
}


function step () {
  /* ── HALT guard ─────────────────────────────────────────── */
  if (cpuState.rip === undefined) {
    console.log('🚫 HALT – no further instructions');
    return;
  }

  /* ── fetch current instruction --------------------------- */
  if (!cpuState.mem) cpuState.mem = {};
  const rip    = cpuState.rip;
  const row    = ripToAsmRow[rip];
  const asmLn  = row != null ? asmEditor.getLine(row) : '';
  const body   = (asmLn.split(':')[1] ?? asmLn).trim();
  const low    = body.toLowerCase();
  const op     = low.split(/\s+/)[0] || '';

  const idx     = instructions.indexOf(rip);
  const seqNext = instructions[idx + 1];  // fall-through

  console.log(`STEP 0x${rip.toString(16)}  ${body}`);

  /* ── helpers --------------------------------------------- */
  const dispRbp = () => {
    const m = low.match(/\[rbp\s*-\s*(0x[0-9a-f]+|\d+)\]/i);
    return m
      ? cpuState.rbp - parseInt(m[1], m[1].startsWith('0x') ? 16 : 10)
      : null;
  };
  const w64 = (a, v) => {
    cpuState.mem[a]   = v & 0xffffffff;
    cpuState.mem[a+4] = (v >>> 32) & 0xffffffff;
  };
  const r64 = a =>
    (cpuState.mem[a] ?? 0)
    | ((cpuState.mem[a+4] ?? 0) << 32);

  /* ── MOV / ADD we actually need -------------------------- */
  if (op === 'mov' && low.includes('[rbp -') && /,\s*eax\s*$/.test(low)) {
    // store EAX → local
    const a = dispRbp();
    if (a !== null) cpuState.mem[a] = cpuState.eax;

  } else if (op === 'mov' &&
             /^\s*mov\s+eax\s*,/.test(low) &&
             low.includes('[rbp -')) {
    // load local → EAX
    const a = dispRbp();
    if (a !== null) cpuState.eax = cpuState.mem[a] ?? 0;

  } else if (op === 'mov' &&
             /^\s*mov\s+ecx\s*,/.test(low) &&
             low.includes('[rbp -')) {
    // load local → ECX
    const a = dispRbp();
    if (a !== null) cpuState.ecx = cpuState.mem[a] ?? 0;

  } else if (op === 'mov' &&
             /^\s*mov\s+eax\s*,/.test(low) &&
             !low.includes('[rbp -')) {
    // immediate → EAX
    const m = low.match(/mov\s+eax\s*,\s*(0x[0-9a-f]+|\d+)/);
    if (m) cpuState.eax = parseInt(m[1], m[1].startsWith('0x') ? 16 : 10);

  } else if (op === 'add' && /^\s*add\s+eax\s*,\s*ecx/.test(low)) {
    // add ECX → EAX
    cpuState.eax = (cpuState.eax + cpuState.ecx) >>> 0;

  } else if (op === 'add' && /^\s*add\s+eax\s*,/.test(low)) {
    // add immediate → EAX
    const m = low.match(/add\s+eax\s*,\s*(0x[0-9a-f]+|\d+)/);
    if (m) cpuState.eax = (cpuState.eax +
             parseInt(m[1], m[1].startsWith('0x') ? 16 : 10)) >>> 0;

  /* ── RDI/EDI rules ───────────────────────────────────────── */
  } else if (op === 'mov' && /mov\s+eax\s*,\s*(r|e)di/.test(low)) {
    cpuState.eax = (cpuState.rdi ?? cpuState.edi) >>> 0;

  } else if (op === 'mov' && /mov\s+(r|e)di\s*,\s*eax/.test(low)) {
    cpuState.rdi = cpuState.eax >>> 0;

  } else if (op === 'mov' && /mov\s+rdi\s*,\s*rax/.test(low)) {
    cpuState.rdi = cpuState.eax >>> 0;
    console.log('↪  RDI now = 0x' + cpuState.rdi.toString(16));

  } else if (op === 'mov' && /mov\s+(r|e)di\s*,\s*(0x[0-9a-f]+|\d+)/.test(low)) {
    const m = low.match(/mov\s+(?:r|e)di\s*,\s*(0x[0-9a-f]+|\d+)/);
    cpuState.rdi = parseInt(m[1], m[1].startsWith('0x') ? 16 : 10) >>> 0;
  }

  /* ── FLAGS from cmp / test ------------------------------- */
  if (op === 'cmp') {
    const m = low.match(/cmp\s+eax\s*,\s*(0x[0-9a-f]+|\d+|ecx)/);
    if (m) {
      const rhs = m[1] === 'ecx'
                  ? cpuState.ecx
                  : parseInt(m[1], m[1].startsWith('0x') ? 16 : 10);
      const a   = cpuState.eax >>> 0,
            b   = rhs >>> 0,
            res = (a - b) >>> 0;
      cpuState.ZF = +(res === 0);
      cpuState.SF = +((res >>> 31) & 1);
      const signA = (a >>> 31) & 1,
            signB = (b >>> 31) & 1,
            signR = (res >>> 31) & 1;
      cpuState.OF = +(signA !== signB && signR !== signA);
    }
  }
  if (op === 'test' && /test\s+eax\s*,\s*eax/.test(low)) {
    cpuState.ZF = +(cpuState.eax === 0);
    cpuState.SF = +((cpuState.eax >>> 31) & 1);
    cpuState.OF = 0;
  }

  /* ── prologue / epilogue ---------------------------------- */
  if (op === 'push' && low.includes('rbp')) {
    cpuState.rsp -= 8; w64(cpuState.rsp, cpuState.rbp);
  } else if (op === 'mov' && low.includes('rbp, rsp')) {
    cpuState.rbp = cpuState.rsp;
  } else if (op === 'sub' && low.includes('rsp,')) {
    const m = low.match(/sub\s+rsp\s*,\s*(0x[0-9a-f]+)/);
    if (m) cpuState.rsp -= parseInt(m[1], 16);
  } else if (op === 'leave') {
    cpuState.rsp = cpuState.rbp;
    cpuState.rbp = r64(cpuState.rsp);
    cpuState.rsp += 8;
  }

  /* ── CALL ------------------------------------------------- */
  if (op === 'call') {
    const m = low.match(/call\s+0x([0-9a-f]+)/);
    if (m) {
      const tgt = parseInt(m[1], 16);
      cpuState.rsp -= 8; w64(cpuState.rsp, seqNext);
      (cpuState.stack ??= []).push(cpuState.rsp);
      cpuState.rip = tgt; refreshUI();
      console.log(`📞 CALL 0x${tgt.toString(16)} (ret→0x${seqNext?.toString(16)})`);
      return;
    }
  }

  /* ── RET -------------------------------------------------- */
  if (op === 'ret') {
    if (!cpuState.stack?.length) {
      cpuState.rip = undefined;
    } else {
      const sp  = cpuState.stack.pop();
      const ret = r64(sp);
      delete cpuState.mem[sp]; delete cpuState.mem[sp+4];
      cpuState.rsp += 8;
      cpuState.rip = ripToAsmRow[ret] ? ret : undefined;
    }
    refreshUI(); return;
  }

  /* ── conditional & jmp ----------------------------------- */
  if (op[0] === 'j' && op !== 'jmp') {
    const tm = low.match(/0x([0-9a-f]+)/);
    if (tm) {
      const tgt = parseInt(tm[1], 16);
      const take =
         (op==='je'||op==='jz')   ? cpuState.ZF :
         (op==='jne'||op==='jnz') ? !cpuState.ZF :
         (op==='jg')              ? (!cpuState.ZF && cpuState.SF===cpuState.OF) :
         (op==='jge')             ? (cpuState.SF===cpuState.OF) :
         (op==='jl')              ? (cpuState.SF!==cpuState.OF) :
         (op==='jle')             ? (cpuState.ZF||cpuState.SF!==cpuState.OF) :
         false;
      cpuState.rip = take ? tgt : seqNext;
      console.log(`↪ ${op.toUpperCase()} ${take?'taken':'not taken'} → 0x${cpuState.rip.toString(16)}`);
      refreshUI(); return;
    }
  }
  if (op === 'jmp') {
    const m = low.match(/jmp\s+0x([0-9a-f]+)/);
    if (m) cpuState.rip = parseInt(m[1], 16);
  }

  /* ── fall-through & end-of-step ─────────────────────────── */
  if (cpuState.rip === rip) cpuState.rip = seqNext;

  refreshUI();
  dbgLine(rip);

  // print named locals if we built varNameMap
  if (Object.keys(varNameMap).length) {
    console.log(
      Object.entries(varNameMap)
            .map(([off, name]) => {
              const v = cpuState.mem[cpuState.rbp - off];
              return `${name}=[rbp-${off}] = ${v===undefined? "(undef)" : v}`;
            })
            .join(", ")
    );
  }

  if (cpuState.rip !== rip) {
    console.log('NEXT →'); dbgLine(cpuState.rip);
  }

  function refreshUI() {
    updateRegs?.();
    updateStack?.();
    highlightAsm?.(cpuState.rip);
    highlightSrc?.(ripToSrcLine[cpuState.rip]);
  }
}









/* ───────────── UI helpers (registers + stack) ─────────────── */
function updateUI(){updateRegs();updateStack();}
function updateRegs () {
  document.getElementById('reg-box').innerHTML =
    `<strong>Registers</strong><pre>
RIP: ${cpuState.rip !== undefined ? '0x'+cpuState.rip.toString(16) : 'HALTED'}
RSP: 0x${cpuState.rsp.toString(16)}    RBP: 0x${cpuState.rbp.toString(16)}

EAX: 0x${cpuState.eax.toString(16).padStart(8,'0')}
ECX: 0x${cpuState.ecx.toString(16).padStart(8,'0')}
RDI: 0x${cpuState.rdi.toString(16).padStart(16,'0')}
</pre>`;
}


function updateStack(){
  const dump=[];const top=cpuState.rsp+0x40,bottom=cpuState.rsp-0x40;
  for(let a=top;a>=bottom;a-=8){
    const empty=cpuState.mem[a]===undefined&&cpuState.mem[a+4]===undefined;
    const val=empty?'   ??':'0x'+read64(a).toString(16).padStart(16,'0');
    let mark='';if(a===cpuState.rsp&&a===cpuState.rbp)mark='← RSP, ← RBP';
    else if(a===cpuState.rsp)mark='← RSP';else if(a===cpuState.rbp)mark='← RBP';
    dump.push(`0x${a.toString(16).padStart(4,'0')}: ${val} ${mark}`);
  }
  document.getElementById('stack-box').innerHTML=`<strong>Stack</strong><pre>${dump.join('\n')}</pre>`;
}

/* reset ------------------------------------------------------ */
function resetStepper(){
  ripToAsmRow={};instructions=[];symbolMap={};asmEditor.setValue('');hexEditor.setValue('');
  cpuState={};document.getElementById('reg-box').innerHTML='<strong>Registers</strong>';
  document.getElementById('stack-box').innerHTML='<strong>Stack</strong>';
}

/* tiny hex helper ------------------------------------------- */
function formatHex(buf){
  let out='';for(let i=0;i<buf.length;i+=16){
    out+=i.toString(16).padStart(4,'0')+': '+[...buf.slice(i,i+16)].map(b=>b.toString(16).padStart(2,'0')).join(' ')+'\n';
  }return out;
}
</script>
</body>
</html>
