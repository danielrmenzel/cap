<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WASM C Compiler & Disassembler</title>
  <style>
    html, body {
      height: 100%; margin: 0; padding: 0;
      background: #8a8a8a;
      box-sizing: border-box;
      font-family: sans-serif;
    }
    body {
      display: flex;
      flex-direction: column;
      padding: 16px;
      gap: 12px;
    }
    .editor-container {
      height: 200px;
      border: 1px solid #ccc;
      resize: vertical;
      overflow: hidden;
    }
    .monaco-editor-instance {
      width: 100%; height: 100%;
    }
    .breakpoint-glyph {
      background-color: rgb(116, 0, 0);
      width: 8px; height: 8px;
      border-radius: 50%;
      margin-left: 6px;
      display: inline-block;
      box-sizing: content-box;
      transform: translateY(4px);
    }
    .step-highlight {
      background-color: rgba(0, 255, 0, 0.2);
    }
    .button-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    button {
      background: #444444;
      padding: 6px 12px;
      font-size: 14px;
      color: #f9f9f9;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.34.1/min/vs/loader.js"></script>
</head>
<body>
  <h2>1. Enter C Code</h2>
  <div class="editor-container">
    <div id="editor" class="monaco-editor-instance"></div>
  </div>
  <div class="button-row">
    <button onclick="compileAndDisasm()">Compile</button>
    <button onclick="debugFromBreakpoint()">Debug</button>
    <button onclick="resetStepper()">‚Ü∫ Reset</button>
  </div>

  <h2>2. Compiled Hex Output</h2>
  <div class="editor-container" style="height: 100px; resize: vertical;">
    <div id="hex-editor" class="monaco-editor-instance"></div>
  </div>

  <h2>3. Disassembled Output</h2>
  <div class="editor-container" style="height: 100px; resize: vertical;">
    <div id="asm-editor" class="monaco-editor-instance"></div>
  </div>

  <script src="../libs/build-wrapper/capstone.js"></script>
  <script src="../libs/build-tcc/tcc.js"></script>

  <script>
    require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.34.1/min/vs' } });
    let editor, hexEditor, asmEditor;
    let capstoneModule, tccModule, disasmFunc;
    let breakpoints = new Set();
    let breakpointDecorations = [];
    let currentStepLine = 1;
    let stepMarker = [];
    let lastDisasmContent = '';

    require(['vs/editor/editor.main'], () => {
      editor = monaco.editor.create(document.getElementById('editor'), {
        value: [
          'int test(int a, int b) {',
          '  int x = 4;',
          '  x++;',
          '  return a + b;',
          '}'
        ].join('\n'),
        language: 'c',
        theme: 'vs-dark',
        automaticLayout: true,
        glyphMargin: true
      });

      editor.onMouseDown(e => {
        if (e.target.type === monaco.editor.MouseTargetType.GUTTER_GLYPH_MARGIN) {
          const line = e.target.position.lineNumber;
          e.event.rightButton ? breakpoints.delete(line)
                              : breakpoints.has(line) ? breakpoints.delete(line) : breakpoints.add(line);
          updateBreakpoints();
        }
      });

      function updateBreakpoints() {
        breakpointDecorations = editor.deltaDecorations(
          breakpointDecorations,
          [...breakpoints].map(line => ({
            range: new monaco.Range(line, 1, line, 1),
            options: {
              isWholeLine: false,
              glyphMarginClassName: 'breakpoint-glyph',
              glyphMarginHoverMessage: { value: '‚õî Breakpoint' }
            }
          }))
        );
      }

      hexEditor = monaco.editor.create(document.getElementById('hex-editor'), {
        value: '', language: 'plaintext', readOnly: true, theme: 'vs-dark', wordWrap: 'on', lineNumbers: 'off',
        fontFamily: 'Courier New', fontSize: 14
      });

      asmEditor = monaco.editor.create(document.getElementById('asm-editor'), {
        value: 'Loading modules‚Ä¶', language: 'plaintext', readOnly: true,
        theme: 'vs-dark', wordWrap: 'on', lineNumbers: 'off'
      });

      initModules();
    });

    async function initModules() {
      capstoneModule = await createCapstoneModule({
        print: txt => appendDisasm(txt), printErr: txt => appendDisasm('[cap err] ' + txt)
      });
      disasmFunc = capstoneModule.cwrap('disasm_x86', null, ['array', 'number']);
      appendDisasm('‚úÖ Capstone loaded.');

      tccModule = await createTCC({
        locateFile: path => path.endsWith('.wasm') || path.endsWith('.data') ? '../libs/build-tcc/' + path : path,
        print: txt => console.log('[tcc] ' + txt),
        printErr: txt => console.error('[tcc err] ' + txt)
      });
      hexEditor.setValue('‚úÖ TinyCC loaded.\n‚è≥Waiting for compilation‚Ä¶');
    }

    function compileAndDisasm() {
      compileToHex(() => runDisasm());
    }

    function compileToHex(callback) {
      const current = hexEditor.getValue();
      hexEditor.setValue(current + '\nüõ†Ô∏è Compiling...');
      setTimeout(() => {
        const code = editor.getValue();
        tccModule.FS.writeFile('input.c', code);
        const lenPtr = tccModule._malloc(4);
        const ptr = tccModule.cwrap('compile_and_get_text', 'number', ['string', 'number'])('input.c', lenPtr);
        const size = tccModule.HEAP32[lenPtr >> 2];
        tccModule._free(lenPtr);
        if (!ptr || !size) return hexEditor.setValue(current + '\n‚ùå Compile failed.');
        const bytes = new Uint8Array(tccModule.HEAPU8.buffer, ptr, size);
        hexEditor.setValue(current + '\n' + formatHex(bytes) + '\n‚úÖ Compilation finished.');
        hexEditor.revealLine(hexEditor.getModel().getLineCount());
        window.lastCompiledBytes = bytes;
        callback?.();
      }, 1000);
    }

    function debugFromBreakpoint() {
      const bpLine = breakpoints.size > 0 ? Math.min(...breakpoints) : currentStepLine;
      highlightLine(bpLine);
      const allLines = editor.getValue().split('\n');
      const debugLines = allLines.slice(0, bpLine);
      const balancedLines = balanceBraces(debugLines);
      const code = balancedLines.join('\n');
      tccModule.FS.writeFile('debug_input.c', code + '\n');

      const lenPtr = tccModule._malloc(4);
      const ptr = tccModule.cwrap('compile_and_get_text', 'number', ['string', 'number'])('debug_input.c', lenPtr);
      const size = tccModule.HEAP32[lenPtr >> 2];
      tccModule._free(lenPtr);
      if (!ptr || !size) return appendDisasm('\n‚ùå Debug compile failed.');
      window.lastCompiledBytes = new Uint8Array(tccModule.HEAPU8.buffer, ptr, size);
      appendDisasm(`\nüß† Debugging line ${bpLine}...`);
      runDisasm();
      currentStepLine = bpLine + 1;
    }

    function balanceBraces(lines) {
      let open = 0, close = 0;
      for (const line of lines) {
        open += (line.match(/{/g) || []).length;
        close += (line.match(/}/g) || []).length;
      }
      while (close < open) {
        lines.push('}');
        close++;
      }
      return lines;
    }

    function resetStepper() {
      currentStepLine = 1;
      highlightLine(null);
      stepMarker = editor.deltaDecorations(stepMarker, []);
      asmEditor.setValue('‚Ü∫ Stepper reset.');
      hexEditor.setValue('‚Ü∫ Reset complete.\n‚è≥Waiting for compilation‚Ä¶');
      lastDisasmContent = '';
    }

    function highlightLine(line) {
      stepMarker = editor.deltaDecorations(stepMarker, line ? [{
        range: new monaco.Range(line, 1, line, 1),
        options: { isWholeLine: true, className: 'step-highlight' }
      }] : []);
    }

    function runDisasm() {
      const buf = window.lastCompiledBytes;
      if (!disasmFunc || !buf) return alert('Missing Capstone or compiled bytes');
      disasmFunc(buf, buf.length);
    }

    function appendDisasm(txt) {
      const current = asmEditor.getValue();
      const newLine = txt.trim();
      if (!current.includes(newLine)) {
        asmEditor.setValue(current + '\n' + newLine);
        asmEditor.revealLine(asmEditor.getModel().getLineCount());
      }
    }

    function formatHex(bytes) {
      const lines = [];
      for (let i = 0; i < bytes.length; i += 16) {
        const chunk = bytes.slice(i, i + 16);
        const hexLine = chunk.map(b => b.toString(16).padStart(2, '0')).join(' ');
        const offset = i.toString(16).padStart(4, '0');
        lines.push(`${offset}: ${hexLine}`);
      }
      return lines.join('\n');
    }
  </script>
</body>
</html>