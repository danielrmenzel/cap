<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WASM C Compiler &amp; Disassembler</title>

  <!-- CodeMirror CSS (base + theme) -->
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.css" />
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/theme/dracula.min.css" />

  <!-- CodeMirror JS Core & Modes -->
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/codemirror.min.js"></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.15/mode/clike/clike.min.js"></script>

  <style>
    html, body {
      height: 100%; margin: 0; padding: 0;
      background: #8a8a8a; font-family: sans-serif;
    }
    body {
      display: flex; flex-direction: column; padding: 16px; gap: 12px;
    }
    .editor-container {
      height: 200px; border: 1px solid #ccc; resize: vertical; overflow: hidden;
    }
    .CodeMirror {
      width: 100%; height: 100%; font-family: monospace; font-size: 14px;
    }
    .step-highlight {
      background-color: rgba(0, 255, 0, 0.2) !important;
    }
    .button-row {
      display: flex; gap: 8px; flex-wrap: wrap;
    }
    button {
      background: #444; padding: 6px 12px; font-size: 14px; color: #f9f9f9;
      border: none; cursor: pointer;
    }
    #cpu-visual {
      display: flex; gap: 16px; margin-top: 12px;
    }
    #reg-box, #stack-box {
      padding: 8px; background: #222; color: #ddd; font-family: monospace;
      overflow-y: auto; max-height: 200px;
    }
    #reg-box { flex: 0 0 200px; }
    #stack-box { flex: 1; border-left: 1px solid #444; padding-left: 12px; }
  </style>
</head>

<body>
  <h2>1. Enter C Code</h2>
  <div class="editor-container"><textarea id="editor"></textarea></div>
  <div class="button-row">
    <button onclick="compileAndDisasm()">Compile</button>
    <button onclick="debugFromBreakpoint()">Debug</button>
    <button onclick="step()">Step</button>
    <button onclick="resetStepper()">↺ Reset</button>
  </div>

  <h2>2. Compiled Hex Output</h2>
  <div class="editor-container" style="height:100px;"><textarea id="hex-editor"></textarea></div>

  <h2>3. Disassembled Output</h2>
  <div class="editor-container" style="height:150px;"><textarea id="asm-editor"></textarea></div>

  <h2>4. CPU State</h2>
  <div class="editor-container" style="height:150px;"><textarea id="cpu-editor"></textarea></div>

  <div id="cpu-visual">
    <div id="reg-box"><strong>Registers</strong></div>
    <div id="stack-box"><strong>Stack</strong></div>
  </div>

  <!-- Capstone for disassembly -->
  <script src="../libs/build-wrapper/capstone.js"></script>

  <!-- TinyCC via Emscripten -->
  <script type="module">
    import('../libs/build-tcc/tcc.mjs').then(m => window.createTCC = m.default);
  </script>

  <script>
    // ————————————————————————————— Globals —————————————————————————————
    let editor, hexEditor, asmEditor, cpuEditor;
    let capstoneModule, tccModule, disasmFunc;
    let breakpoints = new Set();
    let asmStepMarker = [];
    let currentInstrIndex = 0;
    let instructions = [];
    let ripToInstr = {}, ripToSourceLine = {};
    let currentSourceLine = null;
    let isDebugging = false;

    let cpuState = {
      rip: 0x1000,
      rsp: 0x8000,
      rbp: 0x8000,
      stack: []
    };

    // ——————————————————————————— Setup & Editors ———————————————————————————
    function setupEditors() {
      editor = CodeMirror.fromTextArea(document.getElementById("editor"), {
        mode: "text/x-csrc", theme: "dracula",
        lineNumbers: true, gutters: ["CodeMirror-linenumbers"]
      });
      hexEditor = CodeMirror.fromTextArea(document.getElementById("hex-editor"), {
        mode: "plaintext", theme: "dracula", readOnly: true
      });
      asmEditor = CodeMirror.fromTextArea(document.getElementById("asm-editor"), {
        mode: "plaintext", theme: "dracula", readOnly: true
      });
      cpuEditor = CodeMirror.fromTextArea(document.getElementById("cpu-editor"), {
        mode: "plaintext", theme: "dracula", readOnly: true
      });

      // toggle breakpoints
      editor.on("gutterClick", (cm, line) => {
        const ln = line + 1;
        if (breakpoints.has(ln)) breakpoints.delete(ln);
        else breakpoints.add(ln);
        updateBreakpoints();
      });

      // sample code
      editor.setValue(`__attribute__((noinline)) int test(int a, int b) {
    int x = 4;
    x++;
    return a + b;
}

int main() {
    int b = test(3, 44);
    b++;
    int c = b += 3;
}`);

      waitForModules();
    }

    function updateBreakpoints() {
      editor.clearGutter("breakpoints");
      breakpoints.forEach(line => {
        const marker = document.createElement("div");
        marker.style.color = "#f00";
        marker.innerText = "●";
        editor.setGutterMarker(line - 1, "breakpoints", marker);
      });
    }

    function waitForModules() {
      const iv = setInterval(() => {
        if (window.createTCC) {
          clearInterval(iv);
          initModules();
        }
      }, 100);
    }

    window.onload = setupEditors;

    // —————————————————————————— Engine Initialization ——————————————————————————
    async function initModules() {
      capstoneModule = await createCapstoneModule({
        print: txt => appendDisasm(txt),
        printErr: txt => appendDisasm('[cap err] ' + txt)
      });
      disasmFunc = capstoneModule.cwrap('disasm_x86', null, ['array','number']);
      appendDisasm('✅ Capstone loaded.');

      tccModule = await window.createTCC({
        locateFile: p => p.endsWith('.wasm')||p.endsWith('.data')
          ? '../libs/build-tcc/'+p : p,
        print: txt => console.log('[tcc] '+txt),
        printErr: txt => console.error('[tcc err] '+txt)
      });

      hexEditor.setValue('✅ TinyCC loaded.\n⏳Waiting for compilation...');
      updateRegisters();
      updateCPUVisualization();
    }

    // ————————————————————————— CPU Display Helpers —————————————————————————
    function updateRegisters() {
      const regs = 
        `RIP: 0x${cpuState.rip.toString(16)}\n` +
        `RSP: 0x${cpuState.rsp.toString(16)}\n` +
        `RBP: 0x${cpuState.rbp.toString(16)}\n`;
      document.getElementById('reg-box').innerHTML = `<strong>Registers</strong><pre>${regs}</pre>`;
    }

    function updateCPUVisualization() {
      const stackLines = cpuState.stack.map((v,i) => {
        const addr = cpuState.rsp + i*8;
        return `0x${addr.toString(16).padStart(8,'0')} : 0x${v.toString(16).padStart(8,'0')}`;
      }).join('\n');
      document.getElementById('stack-box')
        .innerHTML = `<strong>Stack</strong><pre>${stackLines}</pre>`;
      // also log to CPU-pane
      const prev = cpuEditor.getValue();
      cpuEditor.setValue(prev + stackLines + '\n\n');
      cpuEditor.scrollTo(null, cpuEditor.getScrollInfo().height);
    }

    // ————————————————————————— Compile & Disassemble —————————————————————————
    function compileAndDisasm() {
      compileToHex(() => runDisasm());
    }

    function compileToHex(callback) {
      const code = editor.getValue();
      tccModule.FS.writeFile('input.c', code);
      const lenPtr = tccModule._malloc(4);
      const ptr = tccModule.cwrap(
        'compile_and_get_text', 'number', ['string','number']
      )('input.c', lenPtr);
      const size = tccModule.HEAP32[lenPtr>>2];
      tccModule._free(lenPtr);
      if (!ptr || size <= 0) {
        hexEditor.setValue('❌ Compile failed');
        return;
      }
      const bytes = new Uint8Array(tccModule.HEAPU8.buffer, ptr, size);
      window.lastCompiledBytes = bytes;
      hexEditor.setValue(formatHex(bytes) + '\n✅ Compilation finished.');

      // reset maps
      ripToInstr = {};
      ripToSourceLine = {};
      currentInstrIndex = 0;

      // extract symbol table (optional)
      try {
        const symbolJSON = tccModule.cwrap('extract_symbols','string',['string'])('out.o');
        const parsed = JSON.parse(symbolJSON,(k,v)=>
          typeof v==='string'&&/^\d+$/.test(v)?Number(v):v
        );
        const base = 0x1000, map = {};
        for (let [n,off] of Object.entries(parsed)) map[n]=base+Number(off);
        window.symbolMap = map;
      } catch(e){
        console.warn("Symbol parse failed:", e);
      }

      callback();
    }

    function runDisasm() {
      const buf = window.lastCompiledBytes;
      if (!disasmFunc || !buf) return;
      asmEditor.setValue('');  // clear old
      disasmFunc(buf, buf.length);
      setTimeout(buildInstructionList, 10);
    }

    // ————————————————————————— Build Flat Instruction List —————————————————————————
    function buildInstructionList() {
      instructions = [];
      const lines = asmEditor.getValue().split('\n');
      lines.forEach((line, i) => {
        const m = line.trim().match(/^0x([0-9a-f]+):/);
        if (!m) return;
        const rip = parseInt(m[1], 16);
        const srcLine = ripToSourceLine[rip]||null;
        instructions.push({ rip, asmRow: i, srcLine });
      });
      currentInstrIndex = 0;
    }

    // ————————————————————————— Append Disasm Line —————————————————————————
    function appendDisasm(txt) {
      const newLine = txt.trim();
      let cur = asmEditor.getValue().split('\n');
      if (cur.includes(newLine)) return;
      // detect labels
      if (/^[A-Za-z_]\w*:$/.test(newLine)) {
        const lbl = newLine.slice(0,-1);
        if (lbl==='test') currentSourceLine=1;
        if (lbl==='main') currentSourceLine=7;
      }
      // record instruction→C mapping
      const m = newLine.match(/^0x([0-9a-f]+):/);
      if (m && currentSourceLine!=null) {
        const rip = parseInt(m[1],16);
        ripToSourceLine[rip] = currentSourceLine;
      }
      // append
      cur.push(newLine);
      asmEditor.setValue(cur.join('\n'));
      asmEditor.scrollTo(null, asmEditor.getScrollInfo().height);
    }

    function formatHex(bytes) {
      let out = '';
      for (let i=0; i<bytes.length; i+=16) {
        const chunk = bytes.slice(i,i+16)
                       .map(b=>b.toString(16).padStart(2,'0'))
                       .join(' ');
        out += i.toString(16).padStart(4,'0') + ': ' + chunk + '\n';
      }
      return out;
    }

    // —————————————————————————— Step Through ——————————————————————————
    function step() {
      if (currentInstrIndex >= instructions.length) {
        appendDisasm("✅ End of instructions");
        return;
      }
      const inst = instructions[currentInstrIndex++];
      // highlight asm
      asmEditor.operation(()=>{
        asmStepMarker.forEach(m=>asmEditor.removeLineClass(m,'background','step-highlight'));
        asmStepMarker = [inst.asmRow];
        asmEditor.addLineClass(inst.asmRow,'background','step-highlight');
        asmEditor.scrollIntoView({line:inst.asmRow,ch:0},100);
      });
      // highlight C
      if (inst.srcLine!=null) {
        highlightLine(inst.srcLine);
        currentSourceLine = inst.srcLine;
      }
      // (optional) simulate CPU state
      cpuState.rip = inst.rip;
      updateRegisters();
      updateCPUVisualization();
    }

    // —————————————————————— Debug From Breakpoint ——————————————————————
    async function debugFromBreakpoint() {
      if (isDebugging) return;
      isDebugging = true;

      const bpLine = breakpoints.size>0 ? Math.min(...breakpoints) : 1;
      highlightLine(bpLine);

      // compile+disasm
      compileToHex(() => runDisasm());

      // after disasm, jump RIP→main
      setTimeout(()=>{
        if (window.symbolMap?.main) {
          cpuState.rip = window.symbolMap.main;
          updateRegisters();
          updateCPUVisualization();
          highlightLine(bpLine);
        }
        isDebugging = false;
      }, 100);
    }

    // ————————————————————————— Reset —————————————————————————
    function resetStepper() {
      currentInstrIndex = 0;
      ripToInstr = {}; ripToSourceLine = {};
      asmEditor.setValue(''); hexEditor.setValue(''); cpuEditor.setValue('');
      cpuState = { rip:0x1000, rsp:0x8000, rbp:0x8000, stack: [] };
      highlightLine(null);
      updateRegisters();
      updateCPUVisualization();
    }

    // —————————————————————————— Helpers ——————————————————————————
    function highlightLine(line) {
      const total = editor.lineCount();
      for (let i=0; i<total; i++)
        editor.removeLineClass(i,'background','step-highlight');
      if (line!=null)
        editor.addLineClass(line-1,'background','step-highlight');
    }
  </script>
</body>
</html>
